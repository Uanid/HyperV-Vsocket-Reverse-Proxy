#define WIN32_LEAN_AND_MEAN

#define HV_PROTOCOL_RAW 1


#include <WinSock2.h>
#include <WS2tcpip.h>
#include <iostream>
#include <string>
#include <combaseapi.h>
#include <thread>

// link with Ws2_32.lib
#pragma comment(lib, "Ws2_32.lib")

//#define DEFAULT_PORT "27015" 
#define DEFAULT_BUFFER_LENGTH	8192

struct SOCKADDR_HV
{
	ADDRESS_FAMILY Family;
	USHORT Reserved;
	GUID VmId;
	GUID ServiceId;
};

class Client {
private:
	SOCKET clientSocket;
	char* serverAddr;
	int serverPort;
	int clientType;
	bool isClose;
	char* serviceGuid;
	char* serverGuid;

	bool startTcp() {
		clientSocket = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);
		SOCKADDR_IN hints = {};
		hints.sin_family = AF_INET;
		hints.sin_port = htons(serverPort);
		hints.sin_addr.S_un.S_addr = inet_addr(serverAddr);

		int result = connect(clientSocket, (SOCKADDR*)&hints, sizeof(hints));
		return result != SOCKET_ERROR;
	}

	bool startHyperV(char* serviceGuid, char* serverGuid) {
		SOCKADDR_HV clientService;
		CLSID VmID, ServiceID;

		wchar_t* clsid_str1 = (wchar_t*)malloc(sizeof(wchar_t) * (strlen(serverGuid) + 1));
		for (int i = 0; i < strlen(serverGuid); i++)
		{
			clsid_str1[i] = serverGuid[i];
		}
		clsid_str1[strlen(serverGuid)] = '\0';

		CLSIDFromString(clsid_str1, &VmID); //GUID of Service, generated by powershell
		free(clsid_str1);

		wchar_t* clsid_str22 = (wchar_t*)malloc(sizeof(wchar_t) * (strlen(serviceGuid) + 1));
		for (int i = 0; i < strlen(serviceGuid); i++)
		{
			clsid_str22[i] = serviceGuid[i];
		}
		clsid_str22[strlen(serviceGuid)] = '\0';
		
		CLSIDFromString(clsid_str22, &ServiceID); //GUID of Service, generated by powershell
		free(clsid_str22);
		
		CONST GUID* vmId = &VmID;
		CONST GUID* serviceId = &ServiceID;

		struct addrinfo* result = NULL,
			* ptr = NULL,
			hints;

		//configure protocol
		ZeroMemory(&clientService, sizeof(clientService));
		clientService.Family = AF_HYPERV;
		clientService.VmId = *vmId;
		clientService.ServiceId = *serviceId;

		ZeroMemory(&hints, sizeof(hints));
		hints.ai_family = AF_HYPERV;
		hints.ai_socktype = SOCK_STREAM;
		hints.ai_protocol = HV_PROTOCOL_RAW;
		hints.ai_addrlen = sizeof(SOCKADDR_HV);
		hints.ai_addr = reinterpret_cast<SOCKADDR*>(&clientService);


		clientSocket = socket(hints.ai_family, hints.ai_socktype, hints.ai_protocol);

		if (clientSocket == INVALID_SOCKET)
		{
			printf("Error at socket(): %d\n", WSAGetLastError());
			freeaddrinfo(result);
			WSACleanup();
			return false;
		}

		// Connect to server
		int iResult = connect(clientSocket, hints.ai_addr, (int)hints.ai_addrlen);

		if (iResult == SOCKET_ERROR)
		{
			closesocket(clientSocket);
			clientSocket = INVALID_SOCKET;
		}

		freeaddrinfo(result);

		if (clientSocket == INVALID_SOCKET)
		{
			printf("Unable to connect to server!\n");
			WSACleanup();
			return false;
		}
		return true;
	}

public:
	Client(char* serviceGuid, char* serverGuid) {
		this->clientType = 1;
		this->serviceGuid = serviceGuid;
		this->serverGuid = serverGuid;
		this->isClose = false;
	}

	Client(char* addr, int port) {
		this->serverAddr = addr;
		this->serverPort = port;
		this->clientType = 0;
		this->isClose = false;
	}

	bool start() {
		if (clientType == 0) {
			std::cout << "Tcp client start" << std::endl;
			return startTcp();
		}
		else if (clientType == 1) {
			std::cout << "Hyper-V client start" << std::endl;
			return startHyperV(this->serviceGuid, this->serverGuid);
		}
		else {
			std::cout << "Couldn't specify client type" << std::endl;
			return false;
		}
	}

	bool clientSend(char* buf, int size) {
		int result = send(clientSocket, buf, size, 0);
		return result != SOCKET_ERROR;
	}

	int clientReceive(char* buf, int size) {
		int result = recv(clientSocket, buf, size, 0);
		return result;
	}

	bool close() {
		closesocket(clientSocket);
		this->isClose = true;
		return true;
	}

	bool isClosed() {
		return this->isClose;
	}
};

void forwardFunction(Client *sourceClient, Client *destClient, int type) {
	char recvbuf[DEFAULT_BUFFER_LENGTH];
	while (true) {
		int iResult = sourceClient->clientReceive(recvbuf, DEFAULT_BUFFER_LENGTH);

		if (iResult > 0)
		{
			if (type == 0) {
				printf("Forward Received: %d\n", iResult);
			}
			else {
				printf("Backward Received: %d\n", iResult);
			}

			int iSendResult = destClient->clientSend(recvbuf, iResult);
			if (iSendResult == SOCKET_ERROR)
			{
				printf("send failed: %d %d\n", WSAGetLastError(), type);
				sourceClient->close();
				destClient->close();
				WSACleanup();
				return;
			}
		}
		else if (iResult == 0) {
			printf("Connection closed\n");
			return;
		}
		else
		{
			printf("recv failed: %d %d %d\n", WSAGetLastError(), type, iResult);
			sourceClient->close();
			destClient->close();
			WSACleanup();
			return;
		}
	}
}

int main(int argc, CHAR* argv[])
{
	WSADATA wsaData;
	// Initialize Winsock
	int iResult = WSAStartup(MAKEWORD(2, 2), &wsaData);
	if (iResult != 0)
	{
		printf("WSAStartup failed: %d\n", iResult);
		return false;
	}

	std::cout << "start" << std::endl;

	if (argc < 4) {
		std::cout << "command example" << std::endl;
		std::cout << "<ip> <port> <serviceGuid> [<serverGuid>]" << std::endl;
		return 0;
	}

	char* addr = argv[1];
	char* port = argv[2];
	char* serviceGuid = argv[3];
	char* serverGuid;
	if (argc == 5) {
		serverGuid = argv[4];
	}
	else {
		serverGuid = "{a42e7cda-d03f-480c-9cc2-a4de20abb878}"; // HV_PARENT_GUID
	}

	printf("Target addr: %s, port: %s, serviceGuid: %s, serverGuid: %s\n", addr, port, serviceGuid, serverGuid);

	Client *tunnelClient = new Client(serviceGuid, serverGuid);
	Client *targetClient = new Client(addr, atoi(port));

	if (!tunnelClient->start()) {
		std::cout << "Hyper-V Client Start failed" << std::endl;
		return 1;
	}
	std::cout << "Hyper-V client started" << std::endl;


	if (!targetClient->start()) {
		std::cout << "Tcp Client Start failed" << std::endl;
		return 1;
	}
	std::cout << "Tcp client started" << std::endl;


	std::thread forward(forwardFunction, tunnelClient, targetClient, 0);
	std::thread backward(forwardFunction, targetClient, tunnelClient, 1);

	getchar();

	if (!tunnelClient->isClosed()) {
		tunnelClient->close();
	}
	if (!targetClient->isClosed()) {
		targetClient->close();
	}
	printf("main finish\n");
	WSACleanup(); //from stop funtion
	return 0;
}